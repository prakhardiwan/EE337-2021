#include <at89c5131.h>
#include <stdio.h>	//for sprintf functions
#include "lcd.h"		//Header file with LCD interfacing functions
#include "serial.c"	//C file with UART interfacing functions

sbit LED=P1^7;
//global variables
unsigned char str1[8];
unsigned char str2[8];
//unsigned char str_0[8];
unsigned char map_to_char[16] = "qwertyuiasdfghjk";
unsigned char open_pos_val;  // the value at current open position
unsigned int i = 0;
unsigned count = 0;
unsigned char val[16] = "1234567812345678";
unsigned int lfsr = 0x0004; //B0
unsigned int next_lfsr = 0x0004;		// used for storing next state of lfsr

// uncovered or covered position indicated by for eg: covered[i] = 0 --> uncovered position i ; 1 --> covered position
// all of them are initially covered
unsigned char covered[16]; 

// imp loop values
bit game_over = 0; // 0 --> game going on and 1--> game over
unsigned int min_moves = 1000;	// initialized to a very large value 
unsigned int moves = 0; // no. of moves played in current game

bit even_num_uncov = 1; // 1--> no. of pos uncovered is even ; 0--> odd 	

void re_covered(void){
// initially every position covered
	i = 0;
	for(i;i<16;i=i+1){
		covered[i] = '1';
	}
}
// Display of LCD at various instants of the game
void lcd_game_start_display(void)
{
		lcd_cmd(0x80);
		lcd_write_string("********");
		sprintf(str1,"  %d",moves);
		lcd_write_string(str1);
		msdelay(10);
		lcd_cmd(0xC0);
		lcd_write_string("********");
		if(min_moves == 1000){
			sprintf(str2,"  L:    "); // blank for the first game
		}
		else{
			sprintf(str2,"  L:%d",min_moves);
		}
		lcd_write_string(str2);
		msdelay(100);
}	


// Updating the LCD values corresponding to the given position covered or uncovered bits
void lcd_update(unsigned int m) // 0<=m<=15
{		
		// if no. of pos uncovered is even in that case any covered 
		// spot will be newly uncovered 
		
		if(covered[m]=='1'){
				// show the value at the position to lcd
				if(m<8){		// first line
					lcd_cmd(0x80+m); // add the req value of m to 0x80
					lcd_write_char(val[m]);}
				else{				// second line
					lcd_cmd(0xC0+(m-8));	// add the req value of (m-8) to 0xC0
					lcd_write_char(val[m]);
				}
				lcd_cmd(0x88);
				moves = moves+1;
				sprintf(str1,"  %d",moves);
				lcd_write_string(str1);
				if(even_num_uncov==1){		// newly uncovered position
						// value remains uncovered
						open_pos_val = val[m];
						even_num_uncov = 0;
						covered[m]='0';
				}
				else{		// second of the pair
					if(val[m]==open_pos_val){
						covered[m]='0';
						even_num_uncov = 1;
					}
					else{
						even_num_uncov = 0;
						covered[m]='1';
						msdelay(3000);
						if(m<8){		// first line
							lcd_cmd(0x80+m); // add the req value of m to 0x80
							lcd_write_char('*');}
						else{				// second line
							lcd_cmd(0xC0+(m-8));	// add the req value of (m-8) to 0xC0
							lcd_write_char('*');
						}
					}
				}
		}
		else{// if uncovered is pressed again 
				// Do nothing
		}
}

void next_lf(void){ // will update next_lfsr with itself 
	unsigned int p=0,q=0,r=0;
	q = (next_lfsr & 0x0001);
	r = ((next_lfsr & 0x0008)>>3);
	p = q^r;
	next_lfsr = next_lfsr>>1;
	next_lfsr |= (p<<3);
}
// shuffling the values with pseudo random numbers generated by LFSR
void shuffle_val(){
	unsigned int lfsr_prev = 0x0000; 
	val[lfsr] = '1';
	next_lf();
	val[(lfsr+next_lfsr)%16] = '1';
	
	next_lf();		// updates next_lfsr to next state 
	val[(lfsr+next_lfsr)%16] = '2';
	next_lf();
	val[(lfsr+next_lfsr)%16] = '2';
	
	next_lf();		// updates next_lfsr to next state 
	val[(lfsr+next_lfsr)%16] = '3';
	next_lf();
	val[(lfsr+next_lfsr)%16] = '3';
	
	next_lf();		// updates next_lfsr to next state 
	val[(lfsr+next_lfsr)%16] = '4';
	next_lf();
	val[(lfsr+next_lfsr)%16] = '4';
	
	next_lf();		// updates next_lfsr to next state 
	val[(lfsr+next_lfsr)%16] = '5';
	next_lf();
	val[(lfsr+next_lfsr)%16] = '5';
	
	next_lf();		// updates next_lfsr to next state 
	val[(lfsr+next_lfsr)%16] = '6';
	next_lf();
	val[(lfsr+next_lfsr)%16] = '6';
	
	next_lf();		// updates next_lfsr to next state 
	val[(lfsr+next_lfsr)%16] = '7';
	next_lf();
	val[(lfsr+next_lfsr)%16] = '7';
	
	next_lf();
	val[(lfsr+next_lfsr)%16] = '8';
	lfsr_prev = next_lfsr;
	// last 8 value remains 
	next_lf();
	val[(lfsr+next_lfsr)%16] = '8';
	lfsr = lfsr_prev; // assigns lfsr B0 to last state of lfsr
}

//Main function
void main(void)
{
	unsigned char ch = 0;
	while(1){
		game_over = 0; 
		moves = 0; // resetting number of moves to 0 
		re_covered(); // setting cover bits to 1 again
		
		//Call initialization functions
		lcd_init();
		uart_init();
		count  = 0; // for counting uncovered spots
		lcd_game_start_display();
		
		//These strings will be printed in terminal software
		transmit_string("New Game\r\n");
		
		// Shuffling the numbers after each game
		shuffle_val();
		
		while(game_over==0)
		{
				//Receive a character
				ch = receive_char();
				count = 0;
				//Decide which position to unveil
				//Displays the data on LCD
				i=0;
				for(i; i<16;i=i+1){
						if(ch==map_to_char[i]){
							lcd_update(i);
							transmit_char(map_to_char[i]);
						}
						if(covered[i]=='0'){
							count = count+1;
						}
				}
				if(count==16){
					game_over=1;
					if(moves<min_moves){
					// update minmoves and write to LCD
						min_moves = moves;
						lcd_cmd(0xC8);
						sprintf(str2,"  L:%d",min_moves);
						lcd_write_string(str2);
					}
				}
				msdelay(100);
		}
	}
}